{"ast":null,"code":"import { defineComponent, getCurrentInstance, shallowRef, ref, watch, onMounted, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle } from 'vue';\nimport '../../../../utils/index.mjs';\nimport '../../../../hooks/index.mjs';\nimport { draggable } from '../utils/draggable.mjs';\nimport _export_sfc from '../../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { getClientXY } from '../../../../utils/dom/position.mjs';\nconst _sfc_main = defineComponent({\n  name: \"ElColorAlphaSlider\",\n  props: {\n    color: {\n      type: Object,\n      required: true\n    },\n    vertical: {\n      type: Boolean,\n      default: false\n    }\n  },\n  setup(props) {\n    const ns = useNamespace(\"color-alpha-slider\");\n    const instance = getCurrentInstance();\n    const thumb = shallowRef();\n    const bar = shallowRef();\n    const thumbLeft = ref(0);\n    const thumbTop = ref(0);\n    const background = ref();\n    watch(() => props.color.get(\"alpha\"), () => {\n      update();\n    });\n    watch(() => props.color.value, () => {\n      update();\n    });\n    function getThumbLeft() {\n      if (!thumb.value) return 0;\n      if (props.vertical) return 0;\n      const el = instance.vnode.el;\n      const alpha = props.color.get(\"alpha\");\n      if (!el) return 0;\n      return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);\n    }\n    function getThumbTop() {\n      if (!thumb.value) return 0;\n      const el = instance.vnode.el;\n      if (!props.vertical) return 0;\n      const alpha = props.color.get(\"alpha\");\n      if (!el) return 0;\n      return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);\n    }\n    function getBackground() {\n      if (props.color && props.color.value) {\n        const {\n          r,\n          g,\n          b\n        } = props.color.toRgb();\n        return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;\n      }\n      return \"\";\n    }\n    function handleClick(event) {\n      const target = event.target;\n      if (target !== thumb.value) {\n        handleDrag(event);\n      }\n    }\n    function handleDrag(event) {\n      if (!bar.value || !thumb.value) return;\n      const el = instance.vnode.el;\n      const rect = el.getBoundingClientRect();\n      const {\n        clientX,\n        clientY\n      } = getClientXY(event);\n      if (!props.vertical) {\n        let left = clientX - rect.left;\n        left = Math.max(thumb.value.offsetWidth / 2, left);\n        left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);\n        props.color.set(\"alpha\", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));\n      } else {\n        let top = clientY - rect.top;\n        top = Math.max(thumb.value.offsetHeight / 2, top);\n        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);\n        props.color.set(\"alpha\", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));\n      }\n    }\n    function update() {\n      thumbLeft.value = getThumbLeft();\n      thumbTop.value = getThumbTop();\n      background.value = getBackground();\n    }\n    onMounted(() => {\n      if (!bar.value || !thumb.value) return;\n      const dragConfig = {\n        drag: event => {\n          handleDrag(event);\n        },\n        end: event => {\n          handleDrag(event);\n        }\n      };\n      draggable(bar.value, dragConfig);\n      draggable(thumb.value, dragConfig);\n      update();\n    });\n    return {\n      thumb,\n      bar,\n      thumbLeft,\n      thumbTop,\n      background,\n      handleClick,\n      update,\n      ns\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass([_ctx.ns.b(), _ctx.ns.is(\"vertical\", _ctx.vertical)])\n  }, [createElementVNode(\"div\", {\n    ref: \"bar\",\n    class: normalizeClass(_ctx.ns.e(\"bar\")),\n    style: normalizeStyle({\n      background: _ctx.background\n    }),\n    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))\n  }, null, 6), createElementVNode(\"div\", {\n    ref: \"thumb\",\n    class: normalizeClass(_ctx.ns.e(\"thumb\")),\n    style: normalizeStyle({\n      left: _ctx.thumbLeft + \"px\",\n      top: _ctx.thumbTop + \"px\"\n    })\n  }, null, 6)], 2);\n}\nvar AlphaSlider = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue\"]]);\nexport { AlphaSlider as default };","map":{"version":3,"names":["_sfc_main","defineComponent","name","props","color","type","Object","required","vertical","Boolean","default","setup","ns","useNamespace","instance","getCurrentInstance","thumb","shallowRef","bar","thumbLeft","ref","thumbTop","background","watch","get","update","value","getThumbLeft","el","vnode","alpha","Math","round","offsetWidth","getThumbTop","offsetHeight","getBackground","r","g","b","toRgb","handleClick","event","target","handleDrag","rect","getBoundingClientRect","clientX","clientY","getClientXY","left","max","min","width","set","top","height","onMounted","dragConfig","drag","end","draggable","createElementBlock","class","normalizeClass","_ctx","is","createElementVNode","e","style","normalizeStyle","onClick","_cache","args"],"sources":["../../../../../../../packages/components/color-picker/src/components/alpha-slider.vue"],"sourcesContent":["<template>\n  <div :class=\"[ns.b(), ns.is('vertical', vertical)]\">\n    <div\n      ref=\"bar\"\n      :class=\"ns.e('bar')\"\n      :style=\"{\n        background,\n      }\"\n      @click=\"handleClick\"\n    />\n    <div\n      ref=\"thumb\"\n      :class=\"ns.e('thumb')\"\n      :style=\"{\n        left: thumbLeft + 'px',\n        top: thumbTop + 'px',\n      }\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  getCurrentInstance,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { getClientXY } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { draggable } from '../utils/draggable'\n\nimport type { PropType } from 'vue'\nimport type Color from '../utils/color'\n\nexport default defineComponent({\n  name: 'ElColorAlphaSlider',\n  props: {\n    color: {\n      type: Object as PropType<Color>,\n      required: true,\n    },\n    vertical: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props) {\n    const ns = useNamespace('color-alpha-slider')\n\n    const instance = getCurrentInstance()!\n    // ref\n    const thumb = shallowRef<HTMLElement>()\n    const bar = shallowRef<HTMLElement>()\n\n    // data\n    const thumbLeft = ref(0)\n    const thumbTop = ref(0)\n    const background = ref<string>()\n\n    watch(\n      () => props.color.get('alpha'),\n      () => {\n        update()\n      }\n    )\n    watch(\n      () => props.color.value,\n      () => {\n        update()\n      }\n    )\n\n    //methods\n    function getThumbLeft() {\n      if (!thumb.value) return 0\n\n      if (props.vertical) return 0\n      const el = instance.vnode.el\n      const alpha = props.color.get('alpha')\n\n      if (!el) return 0\n      return Math.round(\n        (alpha * (el.offsetWidth - thumb.value.offsetWidth / 2)) / 100\n      )\n    }\n\n    function getThumbTop() {\n      if (!thumb.value) return 0\n\n      const el = instance.vnode.el\n      if (!props.vertical) return 0\n      const alpha = props.color.get('alpha')\n\n      if (!el) return 0\n      return Math.round(\n        (alpha * (el.offsetHeight - thumb.value.offsetHeight / 2)) / 100\n      )\n    }\n\n    function getBackground() {\n      if (props.color && props.color.value) {\n        const { r, g, b } = props.color.toRgb()\n        return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`\n      }\n      return ''\n    }\n\n    function handleClick(event: MouseEvent | TouchEvent) {\n      const target = event.target\n\n      if (target !== thumb.value) {\n        handleDrag(event)\n      }\n    }\n\n    function handleDrag(event: MouseEvent | TouchEvent) {\n      if (!bar.value || !thumb.value) return\n\n      const el = instance.vnode.el as HTMLElement\n      const rect = el.getBoundingClientRect()\n      const { clientX, clientY } = getClientXY(event)\n\n      if (!props.vertical) {\n        let left = clientX - rect.left\n        left = Math.max(thumb.value.offsetWidth / 2, left)\n        left = Math.min(left, rect.width - thumb.value.offsetWidth / 2)\n\n        props.color.set(\n          'alpha',\n          Math.round(\n            ((left - thumb.value.offsetWidth / 2) /\n              (rect.width - thumb.value.offsetWidth)) *\n              100\n          )\n        )\n      } else {\n        let top = clientY - rect.top\n        top = Math.max(thumb.value.offsetHeight / 2, top)\n        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2)\n\n        props.color.set(\n          'alpha',\n          Math.round(\n            ((top - thumb.value.offsetHeight / 2) /\n              (rect.height - thumb.value.offsetHeight)) *\n              100\n          )\n        )\n      }\n    }\n\n    function update() {\n      thumbLeft.value = getThumbLeft()\n      thumbTop.value = getThumbTop()\n      background.value = getBackground()\n    }\n\n    // mounded\n    onMounted(() => {\n      if (!bar.value || !thumb.value) return\n\n      const dragConfig = {\n        drag: (event: MouseEvent | TouchEvent) => {\n          handleDrag(event)\n        },\n        end: (event: MouseEvent | TouchEvent) => {\n          handleDrag(event)\n        },\n      }\n\n      draggable(bar.value, dragConfig)\n      draggable(thumb.value, dragConfig)\n      update()\n    })\n\n    return {\n      thumb,\n      bar,\n      thumbLeft,\n      thumbTop,\n      background,\n      handleClick,\n      update,\n      ns,\n    }\n  },\n})\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}